---
title: "Week 09 â€“ Describing Categorical Data"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: false
    css: styles.css
editor: visual
---

This week we explore categorical variables using the fictional dataset of 150 summer-school students that we first introduced in Week 1. The aim is to learn how to summarise categorical data numerically and visually in R.

Categorical data appear in many subjects: education, health, psychology, linguistics, business, and more. We often want to know how many people fall into each category, or what proportion of a sample belongs to each group.

To follow the examples, first load the tidyverse:

```{r, echo=TRUE, message=FALSE, warning=FALSE}
library(tidyverse)
```

Then load the dataset:

```{r}
students <- read_csv("Lecture1_data.csv", show_col_types = FALSE)
```

You can view the first few rows:

```{r}
head(students)
```

## Data exploration

Once we have a dataset, a natural first step is toÂ **explore**Â it:

-   What variables do we have?

-   How many students are there?

-   What sort of values do we see?

We can useÂ `summary()`Â to get a quick overview:

```{r}
summary(students)

```

::: callout-important
-   For **numeric variables**, this shows theÂ **minimum**,Â **maximum**,Â **mean**, and so on.\
-   For **categorical variables**, it shows theÂ **number of students**Â in each category.
:::

::: {.callout-note title="Interpreting the Summary for Categorical Variables" collapse="true"}
For **categorical variables**, `summary()` behaves differently depending on **how the variable is stored** in R:

-   If the variable is stored as a **character**, R only reports:
    -   the number of observations\
    -   the class\
    -   the mode
-   If the variable is a **factor**, R also reports the **frequency** of each category.

**Example:**\
In the original dataset, `Gender` is stored as a character, so R prints only structural information:

![](images/Gender.jpg){width="142"}

If we convert the variable to a factor:

```{r}
students$Gender <- factor(students$Gender)
summary(students$Gender)
```

This is much more informative, because you can immediately see how many students belong to each group.
:::

What we are doing here is providing aÂ **numeric description of the distribution**Â of each variable.

> **Distribution**\
> The distribution of a variable shows how often different values occur.

We will focus on describing and visualisingÂ **categorical**Â distributions.

# 1. What Are Categorical Variables?

Categorical variables place individuals intoÂ **groups**. The categories might be:

-   degree subjects

-   year levels

-   gender identities

-   exercise habits

-   stress levels

-   responses on a 1â€“5 rating scale

We distinguish betweenÂ **nominal**Â andÂ **ordinal**Â categories.

### Nominal variables

These categories haveÂ **no natural order**.

Examples in our dataset:

-   `Degree`Â (Architecture, Linguistics, English, Philosophy, Education â€¦)

-   `Gender`Â (Female, Male, Non-binary, etc.)

-   `Exercise`Â (Yes, No)

The category labels are simplyÂ **names**Â â€” they do not imply higher or lower scores.

### Ordinal variables

Ordinal categoriesÂ **have a clear order**.

In our dataset:

-   `Satisfaction_Likert_value`Â (1 = â€œVery Dissatisfiedâ€, 5 = â€œVery Satisfiedâ€)

The order matters, but the difference between levels is not necessarily equal.

# 2. Telling R That a Variable Is Categorical

::: {.callout-tip .margin}
`mutate()`Â modifies or creates variables.\

For example,Â `Gender = factor(Gender)`Â replaces the originalÂ `Gender`Â column with a version stored as a factor.\

All other columns remain unchanged, and the updated data frame continues through the pipe (\|\>)
:::

R reads some categorical variables asÂ **character strings**. To analyse them correctly, we often convert them intoÂ **factors**.

Example:

```{r}
students <- students |>
  mutate(
    Degree       = factor(Degree),
    Gender       = factor(Gender),
    Exercise     = factor(Exercise),
    Stress_level = factor(Stress_level)
  )

```

For anÂ **ordered**Â variable:

```{r}
students <- students |>
  mutate(
    Satisfaction_Likert_value = factor(
      Satisfaction_Likert_value,
      levels = c(1, 2, 3, 4, 5),
      ordered = TRUE
    )
  )

```

# 3. Note about R code: Using the Pipe Operator (`|>`)

### Using the pipeÂ `|>`: reading left to right

Instead, we can write codeÂ **step by step**, using theÂ **pipe**:Â `|>`.

The pipe:

-   takes the output on theÂ **left-hand side**

-   and passes it as the input to what is on theÂ **right-hand side**

You can read it as â€œ**and then**â€.

For example

```{r}
1:10 |>
  diff() |>
  cumsum() |>
  log() |>
  mean() |>
  round()

```

This is easier to read:

> Take the numbers 1 to 10Â **and then**Â take differencesÂ **and then**Â take cumulative sumsÂ **and then**Â take logsÂ **and then**Â take the meanÂ **and then**Â round.

We will use this style a lot in this course, especially with functions fromÂ **tidyverse**.

### An example using our dataset

Letâ€™s say we want to:

1.  start with theÂ `students`Â dataset

2.  pick theÂ `Degree`Â column

3.  count how many students are in each degree

Using the pipe, we can write this clearly:

```{r}
students |>
  select(Degree) |>
  count(Degree)


```

### How to read this

-   Take theÂ `students`Â data

-   **and then**Â 'select' the column calledÂ `Degree`

-   **and then**Â 'count' how many times each degree appears

This is easier to read than nesting everything inside one line, such as:

```{r}
count(select(students, Degree), Degree)

```

### Another example

Imagine we want to:

1.  take theÂ `Year`Â column

2.  count how many students are in each year

3.  add percentages

```{r}
students |>
  count(Year) |>
  mutate(Percent = round((n / sum(n))*100, 1))

```

Read it as:

-   start withÂ `students`

-   **and then**Â count how many students are in eachÂ `Year`

-   **and then**Â create a new column with percentages

::: note
### AboutÂ `%>%`

You may still see the older pipe symbolÂ `%>%`Â in online examples:

```{r}
students %>% select(Degree) %>% count(Degree)

```

It works in exactly the same way, but the newerÂ `|>`Â is now preferred.
:::

# 4. Summary Statistics :

### 4.1 Frequency Tables

A frequency table showsÂ **how many**Â observations fall into each category.

### Example: how many students are in each degree?

```{r}
students |>
  count(Degree)

```

This is aÂ **frequency table**Â forÂ `Degree`.

We might store it in an object:

```{r}
freq_degree <-
  students |>
  count(Degree)

freq_degree

```

NowÂ `freq_degree`Â contains one row per degree subject, with the count in a column calledÂ `n`.

### 4.2 Mode

Sometimes we want aÂ **single value**Â that represents where most observations fall. For nominal data, the only measure of central tendency we can use is theÂ **mode**.

> **Mode**\
> The mode is the most frequent value (the category with the highest count).

In our example, the mode is the degree subject with the largestÂ `n`Â in the table. For instance, if Linguistics has the highest count, then the mode ofÂ `Degree`Â isÂ *Linguistics*.

### 4.3 Relative frequencies (proportions and percentages)

Instead of just showing counts, we might want to showÂ **proportions**Â orÂ **percentages**.

> **Relative frequency**\
> A relative frequency is theÂ **proportion**Â of observations in a given category.\
> It can be written as:
>
> -   aÂ **proportion**Â (e.g. 0.40)
>
> -   aÂ **percentage**Â (e.g. 40%)

The sum of relative frequencies is 1 (or 100%).

In ourÂ `freq_degree`Â table, the columnÂ `n`Â contains the number of students in each degree. The total of that column is the total number of students:

```{r}
sum(freq_degree$n)

```

Each value divided by the total gives us aÂ **proportion**:

```{r}
freq_degree$n / sum(freq_degree$n)

```

We can add this as a new column usingÂ `mutate()`:

```{r}
freq_degree <-
  students |>
  count(Degree) |>
  mutate(
    prop = n / sum(n)
  )

freq_degree

```

NowÂ `freq_degree`Â has:

-   `Degree`

-   `n`Â (count)

-   `prop`Â (proportion of students in that degree)

If we preferÂ **percentages**, we can multiply by 100:

```{r}
freq_degree <-
  students |>
  count(Degree) |>
  mutate(
    percent = n / sum(n) * 100
  )

freq_degree

```

### Another way of adding percentages:

```{r}
students |>
  count(Degree) |>
  mutate(Percent = round((n / sum(n)) * 100, 2))

```

This tells us:

-   how many students study each subject

-   what percentage of the sample that group represents

You can repeat this for variables such asÂ `Gender`,Â `Exercise`, orÂ `Stress_level`.

:::::: {.panel-tabset title="ğŸ“ Proportions vs Percentages"}
## Whatâ€™s the Difference?

-   A **proportion** is a number between 0 and 1\
    â†’ e.g., 0.25\
-   A **percentage** is the same value multiplied by 100\
    â†’ e.g., 25%

ğŸ’¡ They show the same information â€” just in different formats.

In our dataset, we might want to know:

-   what **proportion** of students study each Degree subject\
-   what **percentage** that corresponds to

------------------------------------------------------------------------

## When to Use Each

-   Use **proportions** for analysis and statistical functions\
    â†’ e.g., chi-square tests\
-   Use **percentages** when reporting results\
    â†’ e.g., â€œ54% of students study Linguisticsâ€

Choose whichever best fits your purpose.

------------------------------------------------------------------------

## Quick Reference Table

| Proportion | Percentage |
|-----------:|-----------:|
|       0.25 |        25% |
|       0.50 |        50% |
|       0.75 |        75% |

------------------------------------------------------------------------

## In R: Show Both for `Degree`

### Count how many students are in each degree subject

::: narrow-table
```{r}
# Count the number of students in each Degree category
tbl_degree <- as.data.frame(table(students$Degree))   # <1>
colnames(tbl_degree) <- c("Degree", "Count")

knitr::kable(tbl_degree)
```

1.table(students\$Degree) counts how many students are in each subject.
:::

::: narrow-table
```{r}

prop_degree <- as.data.frame(prop.table(table(students$Degree)))   # <2>
colnames(prop_degree) <- c("Degree", "Proportion")

knitr::kable(prop_degree)

```

2.Convert counts into proportions (values between 0 and 1)
:::

::: narrow-table
```{r}

# Percentage of students in each Degree category

perc_degree <- as.data.frame(round(prop.table(table(students$Degree)) * 100, 1))   # <3>
colnames(perc_degree) <- c("Degree", "Percentage")

knitr::kable(perc_degree)

```

3.  Multiply the proportions by 100 and round to one decimal place.
:::
::::::

# 5. Bar Charts for Categorical Data\*\*

Bar charts visually display frequency distribution â€” useful for spotting patterns at a glance.

### Degree distribution

```{r}
ggplot(students, aes(x = Degree)) +
  geom_bar(fill = "steelblue4") +
  labs(x = "\n Degree subject", y = "Count \n")

```

You can change the colour:

```{r}
geom_bar(fill = "darkgreen")

```

```{r}
ggplot(students, aes(x = Degree)) +
  geom_bar(fill = "darkgreen") +
  labs(x = "\n Degree subject", y = "Count \n")
```

## Changing the order of categories

### Sometimes you want degrees to appear in a particular order:

```{r}
students |>
  mutate(Degree = factor(Degree,
                         levels = c("Architecture", "Linguistics",
                                    "English", "Philosophy", "Education"))) |>
  ggplot(aes(x = Degree)) +
  geom_bar(fill = "steelblue4") +
  labs(x = "\n Degree subject", y = "Count \n")

```

### Reorder by frequency

```{r}
library(tidyverse)

students |>
  mutate(Degree = fct_infreq(students$Degree)) |>
  ggplot(aes(x = Degree)) +
  geom_bar(fill = "steelblue4") +
  labs(x = "\n Degree subject", y = "Count \n")

```

### What this does

-   `fct_infreq(Degree)`Â reorders DegreeÂ **from most common â†’ least common**.

-   The bar chart will display the degrees in order of their counts.

### **Reverse the order (least common â†’ most common)**

```{r}
students |>
  mutate(Degree = fct_rev(fct_infreq(Degree))) |>
  ggplot(aes(x = Degree)) +
  geom_bar(fill = "steelblue4") +
  labs(x = "\n Degree subject", y = "Count \n")

```

::: {.callout-tip title="Want to learn more about ggplot?"}
For a deeper explanation of **ggplot**, including the grammar of graphics,\
aesthetics, geoms, and themes, see the **Plots & Grammar page**.

[Plots and Grammar â€“ How ggplot Works](plots_grammar.qmd)
:::

::: panel-tabset
### `fct_infreq()`

**Meaning:**\
Reorders a factor so that categories appear from **most common â†’ least common**.

**Example:**\
If your Degree counts are:

-   Linguistics: 60 students\
-   English: 40 students\
-   Philosophy: 20 students\
-   Architecture: 10 students

Then:

fct_infreq(Degree)

reorders the categories as:

1.  Linguistics

2.  English

3.  Philosophy

4.  Architecture

This means your bar chart will display categories in order ofÂ **highest to lowest**Â frequency.

------------------------------------------------------------------------

### `fct_rev()`

**Meaning:**\
Reverses the order of the factor levels.

**Example (continuing from the previous one):**

If the order is:

1.  Linguistics

2.  English

3.  Philosophy

4.  Architecture

then:

fct_rev(Degree)

flips the order to:

1.  Architecture

2.  Philosophy

3.  English

4.  Linguistics

This givesÂ **lowest â†’ highest**Â frequency.

------------------------------------------------------------------------

### Combining them:Â `fct_rev(fct_infreq())`

**Meaning:**\
First reorder categories byÂ **frequency**, thenÂ **reverse**Â the order.

This gives a clear and useful order:

-   **from least common â†’ most common**

Example:

mutate(Degree = fct_rev(fct_infreq(students\$Degree)))

Step-by-step:

1.  `fct_infreq(Degree)`\
    â†’ orders fromÂ *most common â†’ least common*\
    (Linguistics â†’ English â†’ Philosophy â†’ Architecture)

2.  `fct_rev(...)`\
    â†’ reverses that order\
    (Architecture â†’ Philosophy â†’ English â†’ Linguistics)

This final arrangement is often helpful in bar charts because it starts with theÂ **smallest group**Â and ends with theÂ **largest**, making the pattern easy to read.
:::

## 6. Ordinal Data

Some categorical variables in theÂ `students`Â dataset have aÂ **natural order**. For example:

For example:

-   `Satisfaction_Likert_value`Â might range from 1 to 5, with\
    1 = â€œVery dissatisfiedâ€\
    5 = â€œVery satisfiedâ€

Although the values are stored as numbers, they representÂ **ordered categories**, not true numeric measurements.

### 6.1 Frequency table for an ordinal variable

This gives the number of students choosing each response.

```{r}
students |>
  count(Satisfaction_Likert_value)

```

### 6.2 We can again use relative frequencies:

We can also calculate theÂ **percentage**Â choosing each category:

```{r}
freq_sat <-
  students |>
  count(Satisfaction_Likert_value) |>
  mutate(
    percent = n / sum(n) * 100
  )

freq_sat

```

This helps us compare how common each category is.

### 6.3 The Median for an Ordinal Variable

Because ordinal categories have an order, we can meaningfully talk about theÂ **median**.

> **Definition:**\
> The median is the value for which 50% of observations are lower and 50% are higher.\
> It is the middle value when all observations are lined up in order.

We can find the median of the satisfaction ratings directly:

```{r}
median(as.numeric(students$Satisfaction_Likert_value))

```

> -   The median satisfaction rating is 4.
>
> -   This means that at least half of the students gave a rating of 4 (â€œSatisfiedâ€) or higher.

### 6.4 Cumulative percentages and quartiles

To findÂ **quartiles**, we useÂ **cumulative percentages**.

> **Cumulative percentage**\
> The cumulative percentage for a category is the percentage of observations in that categoryÂ **or below**Â it.

We can calculate cumulative percentages for the satisfaction ratings:

```{r}
students |>
  count(Satisfaction_Likert_value) |>
  mutate(
    percent = n / sum(n) * 100,
    cumulative_percent = cumsum(percent)
  )

```

From this table, we can work out theÂ **quartiles**Â and theÂ **median**:

-   **Q1 (first quartile):**Â first category where cumulative % â‰¥Â **25%**

-   **Q2 (median):**Â first category where cumulative % â‰¥Â **50%**

-   **Q3 (third quartile):**Â first category where cumulative % â‰¥Â **75%**

Using the values in the table:

| Quartile        | Rule             | Likert value |
|-----------------|------------------|--------------|
| **Q1**          | cumulative â‰¥ 25% | **2**        |
| **Q2 (Median)** | cumulative â‰¥ 50% | **4**        |
| **Q3**          | cumulative â‰¥ 75% | **5**        |

#### Interpretation

Most students rate their satisfaction at the higher end of the scale, with the majority of responses in categoriesÂ **4**Â andÂ **5**, and only a small number giving mid-range ratings (category 3).

#### **Does this interpretation sound counter-intuitive?**

Let's recap: what the data look like:

```{r, echo=FALSE}

library(dplyr)
library(knitr)

quartile_table <-
  students |>
    count(Satisfaction_Likert_value) |>
    arrange(Satisfaction_Likert_value) |>
    mutate(
      percent_raw  = n / sum(n) * 100,
      cum_raw      = cumsum(percent_raw),
      percent      = round(percent_raw, 1),
      cumulative_percent = round(cum_raw, 1),
      Quartile = case_when(
        cum_raw >= 25 & lag(cum_raw, default = 0) < 25 ~ "Q1",
        cum_raw >= 50 & lag(cum_raw, default = 0) < 50 ~ "Q2 (Median)",
        cum_raw >= 75 & lag(cum_raw, default = 0) < 75 ~ "Q3",
        TRUE ~ ""
      ),
      Rule = case_when(
        Quartile == "Q1" ~ "First cumulative â‰¥ 25%",
        Quartile == "Q2 (Median)" ~ "First cumulative â‰¥ 50%",
        Quartile == "Q3" ~ "First cumulative â‰¥ 75%",
        TRUE ~ ""
      )
    )

quartile_table |>
  select(
    Satisfaction_Likert_value,
    n,
    percent,
    cumulative_percent,
    Quartile,
    Rule
  ) |>
  kable(
    col.names = c(
      "Likert Value",
      "Count",
      "Percent (%)",
      "Cumulative (%)",
      "Quartile",
      "Rule"
    ),
    align = "c"
  )


```

**Note:** Q3 falls at Likert value 5 because cumulative percentage reaches 75% only when category 5 is included. Even though category 4 has many responses, it is not enough to reach 75% on its own.

::: {.callout-tip title="Important Clarifications when Identifying Quartiles" collapse="true"}
1.  You always **choose the first category that meets the threshold**

    If cumulative jumps over the quartile threshold (e.g., from 3% to 31.5%), that category still contains the quartile.

2.  **Overshooting is fine** .

    Quartiles do not require the cumulative percentage to equal the threshold â€” only to be greater than or equal.

3.  **Quartiles depend on cumulative percentages, not on category sizes**.

    Even if a category is very large or very small, quartiles are determined only by: ordering of the categories cumulative distribution across them

4.  **Quartiles may repeat categories**.

    It is possible for Q2 and Q3 to be the same category if that category contains both the 50% and 75% thresholds.

5.  **Quartiles do not need to fall in the â€œmiddleâ€ category.**

    In skewed ordinal data, quartiles often fall: higher than students expect or both in the same category or in categories with small raw counts This is normal.
:::

## 7 Visualising ordinal data

We can visualise ordinal data much like nominal data.

First, we create a table with percentages:

```{r}
freq_sat <-
  students |>
  count(Satisfaction_Likert_value) |>
  mutate(
    percent = n / sum(n) * 100
  )

freq_sat
```

Then we plot:

```{r}
ggplot(data = freq_sat,
       aes(x = Satisfaction_Likert_value, y = percent)) +
  geom_col() +
  labs(
    x = "\n Satisfaction (1 = very dissatisfied, 5 = very satisfied)",
    y = "Percentage of students \n"
  )

```

This shows how the students are distributed across the satisfaction scale.

### Example 2 : Categorical variable (Year)

```{r}
ggplot(students, aes(x = Year)) +
  geom_bar(fill = "steelblue4") +
  labs(x = "\n Year of study", y = "Count \n")

```

For an ordered variable such asÂ `Year`, we can examineÂ **cumulative percentages**.

```{r}
students |>
  count(Year) |>
  mutate(
    Percent    = round((n / sum(n)) * 100, 2),
    Cumulative = cumsum(Percent)
  )

```

This helps us see:

-   where theÂ **25%**Â point lies (Q1)

-   where theÂ **50%**Â point lies (median)

-   where theÂ **75%**Â point lies (Q3)

### **Checking quartiles in R**

R can calculate the quartiles of an ordered variable directly:

```{r}
quantile(students$Year, c(0.25, 0.50, 0.75))

```

### **Median in R - Year**

```{r}
median(students$Year)

```

The median (Q2) identifies the category at whichÂ **50% of students are in Year 1 or 2**, andÂ **50% are in Year 2 or 3**(depending on distribution).

For ordinal data likeÂ `Year`, the median is interpreted as:

> The â€œmiddleâ€ year category where half of the students are below and half are above.

### **Interquartile range (IQR)**

-   TheÂ **interquartile range (IQR)**Â is a measure ofÂ **spread**.

-   It tells usÂ **where the middle 50% of the data lie**.

The IQR is defined as:

IQR=Q3âˆ’Q1

-   **Q1 (first quartile):**Â the value at the 25% point

-   **Q3 (third quartile):**Â the value at the 75% point

So the IQR covers the range between the 25th and 75th percentiles.

**It describes the spread of the middle half of the dataset.**

**In R we calculate the IQR like this:**

`IQR()`Â computes:

> **IQR = Q3 âˆ’ Q1**
>
> IQR = 2-1 =1

```{r}
IQR(students$Year)

```

This means that **the middle 50% of students fall between Year 1 and Year 2.**

### Median or IQR ?

**Median:**Â theÂ *middle value*\
**IQR:**Â theÂ *spread of the middle 50%*

-   TheÂ **median**Â tells usÂ **where the centre of the data is**

-   TheÂ **IQR**Â tells usÂ **how spread out the central half of the data is**

Together, they describe theÂ **typical**Â part of the dataset.

::: {.callout-note title="Example 1: Interpreting Year" collapse="true"}
| Year | Cumulative % |
|------|--------------|
| 1    | 31.5%        |
| 2    | 76%          |
| 3    | 100%         |

### **Median (Q2)**

The median is the point where cumulative % â‰¥Â **50%**.\

-   The median Year =Â **2**

**Interpretation:**

The typical student is inÂ **Year 2**.

### **IQR (Q3 â€“ Q1)**

-   **Q1**Â is first cumulative â‰¥ 25% â†’Â **Year 1**

-   **Q3**Â is first cumulative â‰¥ 75% â†’Â **Year 2**

So:

-    IQR = 2âˆ’1=1

**Interpretation:**

The middle half of students fall betweenÂ **Year 1 and Year 2**.\
This shows that most students are in the lower two years, with fewer in Year 3.
:::

::: {.callout-note title="Example 2: Interpreting Likert Satisfaction" collapse="true"}
If your satisfaction distribution gives:

-   Q1 = 2

-   Median = 4

-   Q3 = 4

Then:

-   Median = 4 â†’ the central response is â€œSatisfiedâ€.

-   IQR = 4 âˆ’ 2 = 2 (spread across categories 2â€“4)

**Interpretation:**

Half of the students rate their satisfaction between 2 (â€˜Dissatisfiedâ€™) and 4 (â€˜Satisfiedâ€™). Responses cluster in the mid-to-high end of the scale.
:::

## 8. Glossary

| Term / Function | Meaning |
|----------------------------------------------|--------------------------|
| **distribution** | How often different possible values of a variable occur. |
| **frequency** | Number of observations in a given category (a count). |
| **relative frequency** | Proportion or percentage of observations in a given category. |
| **cumulative percentage** | Percentage of observations in or below a given category (requires ordered data). |
| **mode** | Most common value (the category with the highest frequency). |
| **median** | Middle value when the data are ordered. |
| **`|>`** | Pipe operator. Takes the output on the left and passes it as input to the function on the right. |
| **`count()`** | Counts the number of occurrences of each unique value in a variable. |
| **`mutate()`** | Adds new variables or modifies existing variables in a dataframe. |
| **`median()`** | Returns the median of a numeric or ordered variable. |
| **`ggplot()`** | Creates a plot. Uses `data =` and `aes()` to map variables to plot features (e.g. x-axis, y-axis, colours). |
| **`geom_col()`** | Adds columns (bars) to a ggplot using the supplied y-values. |

::: callout-note
For more examples of ggplot and the grammar of graphics, see\
[Plots and the Grammar of Graphics](Plots_and_grammar.qmd).
:::


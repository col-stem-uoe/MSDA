---
title: "Week 09 â€“ Describing Categorical Data"
format:
  html:
    toc: true
    toc-depth: 3
    code-fold: false
    css: styles.css
editor: visual
---

This week we explore categorical variables using the fictional dataset of 150 summer-school students that we first introduced in Week 1. The aim is to learn how to summarise categorical data numerically and visually in R.

Categorical data appear in many subjects: education, health, psychology, linguistics, business, and more. We often want to know how many people fall into each category, or what proportion of a sample belongs to each group.

To follow the examples, first load the tidyverse:

```{r}
library(tidyverse)
```

Then load the dataset:

```{r}
students <- read_csv("Lecture1_data.csv", show_col_types = FALSE)
```

You can view the first few rows:

```{r}
head(students)
```

## Data exploration

Once we have a dataset, a natural first step is toÂ **explore**Â it:

-   What variables do we have?

-   How many students are there?

-   What sort of values do we see?

We can useÂ `summary()`Â to get a quick overview:

```{r}
summary(students)

```

For numeric variables, this shows theÂ **minimum**,Â **maximum**,Â **mean**, and so on.\
For categorical variables, it shows theÂ **number of students**Â in each category.

What we are doing here is providing aÂ **numeric description of the distribution**Â of each variable.

> **Distribution**\
> The distribution of a variable shows how often different values occur.

We will focus on describing and visualisingÂ **categorical**Â distributions.

# **1. What Are Categorical Variables?**

Categorical variables place individuals intoÂ **groups**. The categories might be:

-   degree subjects

-   year levels

-   gender identities

-   exercise habits

-   stress levels

-   responses on a 1â€“5 rating scale

We distinguish betweenÂ **nominal**Â andÂ **ordinal**Â categories.

### **Nominal variables**

These categories haveÂ **no natural order**.

Examples in our dataset:

-   `Degree`Â (Architecture, Linguistics, English, Philosophy, Education â€¦)

-   `Gender`Â (Female, Male, Non-binary, etc.)

-   `Exercise`Â (Yes, No)

The category labels are simplyÂ **names**Â â€” they do not imply higher or lower scores.

### **Ordinal variables**

Ordinal categoriesÂ **have a clear order**.

In our dataset:

-   `Satisfaction_Likert_value`Â (1 = â€œVery Dissatisfiedâ€, 5 = â€œVery Satisfiedâ€)

The order matters, but the difference between levels is not necessarily equal.

# **2. Telling R That a Variable Is Categorical**

R reads some categorical variables asÂ **character strings**. To analyse them correctly, we often convert them intoÂ **factors**.

Example:

```{r}
students <- students |>
  mutate(
    Degree       = factor(Degree),
    Gender       = factor(Gender),
    Exercise     = factor(Exercise),
    Stress_level = factor(Stress_level)
  )

```

For anÂ **ordered**Â variable:

```{r}
students <- students |>
  mutate(
    Satisfaction_Likert_value = factor(
      Satisfaction_Likert_value,
      levels = c(1, 2, 3, 4, 5),
      ordered = TRUE
    )
  )

```

# **3. Note about R code: Using the Pipe Operator (`|>`)**

### Using the pipeÂ `|>`: reading left to right

Instead, we can write codeÂ **step by step**, using theÂ **pipe**:Â `|>`.

The pipe:

-   takes the output on theÂ **left-hand side**

-   and passes it as the input to what is on theÂ **right-hand side**

You can read it as â€œ**and then**â€.

For example

```{r}
1:10 |>
  diff() |>
  cumsum() |>
  log() |>
  mean() |>
  round()

```

This is easier to read:

> Take the numbers 1 to 10Â **and then**Â take differencesÂ **and then**Â take cumulative sumsÂ **and then**Â take logsÂ **and then**Â take the meanÂ **and then**Â round.

We will use this style a lot in this course, especially with functions fromÂ **tidyverse**.

### **An example using our dataset**

Letâ€™s say we want to:

1.  start with theÂ `students`Â dataset

2.  pick theÂ `Degree`Â column

3.  count how many students are in each degree

Using the pipe, we can write this clearly:

```{r}
students |>
  select(Degree) |>
  count(Degree)


```

### **How to read this**

-   Take theÂ `students`Â data

-   **and then**Â 'select' the column calledÂ `Degree`

-   **and then**Â 'count' how many times each degree appears

This is easier to read than nesting everything inside one line, such as:

```{r}
count(select(students, Degree), Degree)

```

### **Another very simple example**

Imagine we want to:

1.  take theÂ `Year`Â column

2.  count how many students are in each year

3.  add percentages

```{r}
students |>
  count(Year) |>
  mutate(Percent = round((n / sum(n))*100, 1))

```

Read it as:

-   start withÂ `students`

-   **and then**Â count how many students are in eachÂ `Year`

-   **and then**Â create a new column with percentages

::: note
### **AboutÂ `%>%`**

You may still see the older pipe symbolÂ `%>%`Â in online examples:

```{r}
students %>% select(Degree) %>% count(Degree)

```

It works in exactly the same way, but the newerÂ `|>`Â is now preferred.
:::

# **4. Summary Statistics :**

### **4.1 Frequency Tables**

A frequency table showsÂ **how many**Â observations fall into each category.

### Example: how many students are in each degree?

```{r}
students |>
  count(Degree)

```

This is aÂ **frequency table**Â forÂ `Degree`.

We might store it in an object:

```{r}
freq_degree <-
  students |>
  count(Degree)

freq_degree

```

NowÂ `freq_degree`Â contains one row per degree subject, with the count in a column calledÂ `n`.

### 4.2 Mode

Sometimes we want aÂ **single value**Â that represents where most observations fall. For nominal data, the only measure of central tendency we can use is theÂ **mode**.

> **Mode**\
> The mode is the most frequent value (the category with the highest count).

In our example, the mode is the degree subject with the largestÂ `n`Â in the table. For instance, if Linguistics has the highest count, then the mode ofÂ `Degree`Â isÂ *Linguistics*.

### 4.3 Relative frequencies (proportions and percentages)

Instead of just showing counts, we might want to showÂ **proportions**Â orÂ **percentages**.

> **Relative frequency**\
> A relative frequency is theÂ **proportion**Â of observations in a given category.\
> It can be written as:
>
> -   aÂ **proportion**Â (e.g. 0.40)
>
> -   aÂ **percentage**Â (e.g. 40%)

The sum of relative frequencies is 1 (or 100%).

In ourÂ `freq_degree`Â table, the columnÂ `n`Â contains the number of students in each degree. The total of that column is the total number of students:

```{r}
sum(freq_degree$n)

```

Each value divided by the total gives us aÂ **proportion**:

```{r}
freq_degree$n / sum(freq_degree$n)

```

We can add this as a new column usingÂ `mutate()`:

```{r}
freq_degree <-
  students |>
  count(Degree) |>
  mutate(
    prop = n / sum(n)
  )

freq_degree

```

NowÂ `freq_degree`Â has:

-   `Degree`

-   `n`Â (count)

-   `prop`Â (proportion of students in that degree)

If we preferÂ **percentages**, we can multiply by 100:

```{r}
freq_degree <-
  students |>
  count(Degree) |>
  mutate(
    percent = n / sum(n) * 100
  )

freq_degree

```

### Another way of adding percentages:

```{r}
students |>
  count(Degree) |>
  mutate(Percent = round((n / sum(n)) * 100, 2))

```

This tells us:

-   how many students study each subject

-   what percentage of the sample that group represents

You can repeat this for variables such asÂ `Gender`,Â `Exercise`, orÂ `Stress_level`.

:::::: {.panel-tabset title="ğŸ“ Proportions vs Percentages"}
## Whatâ€™s the Difference?

-   A **proportion** is a number between 0 and 1\
    â†’ e.g., 0.25\
-   A **percentage** is the same value multiplied by 100\
    â†’ e.g., 25%

ğŸ’¡ They show the same information â€” just in different formats.

In our dataset, we might want to know:

-   what **proportion** of students study each Degree subject\
-   what **percentage** that corresponds to

------------------------------------------------------------------------

## When to Use Each

-   Use **proportions** for analysis and statistical functions\
    â†’ e.g., chi-square tests\
-   Use **percentages** when reporting results\
    â†’ e.g., â€œ54% of students study Linguisticsâ€

Choose whichever best fits your purpose.

------------------------------------------------------------------------

## Quick Reference Table

| Proportion | Percentage |
|-----------:|-----------:|
|       0.25 |        25% |
|       0.50 |        50% |
|       0.75 |        75% |

------------------------------------------------------------------------

## In R: Show Both for `Degree`

### Count how many students are in each degree subject

::: narrow-table
```{r}
# Count the number of students in each Degree category
tbl_degree <- as.data.frame(table(students$Degree))   # <1>
colnames(tbl_degree) <- c("Degree", "Count")

knitr::kable(tbl_degree)
```

1.table(students\$Degree) counts how many students are in each subject.
:::

::: narrow-table
```{r}

prop_degree <- as.data.frame(prop.table(table(students$Degree)))   # <2>
colnames(prop_degree) <- c("Degree", "Proportion")

knitr::kable(prop_degree)

```

2.Convert counts into proportions (values between 0 and 1)
:::

::: narrow-table
```{r}

# Percentage of students in each Degree category

perc_degree <- as.data.frame(round(prop.table(table(students$Degree)) * 100, 1))   # <3>
colnames(perc_degree) <- c("Degree", "Percentage")

knitr::kable(perc_degree)

```

3.  Multiply the proportions by 100 and round to one decimal place.
:::
::::::

# **5. Bar Charts for Categorical Data**

Bar charts visually display frequency distribution â€” useful for spotting patterns at a glance.

### Degree distribution

```{r}
ggplot(students, aes(x = Degree)) +
  geom_bar(fill = "steelblue4") +
  labs(x = "\n Degree subject", y = "Count \n")

```

You can change the colour:

```{r}
geom_bar(fill = "darkgreen")

```

```{r}
ggplot(students, aes(x = Degree)) +
  geom_bar(fill = "darkgreen") +
  labs(x = "\n Degree subject", y = "Count \n")
```

## Changing the order of categories

### Sometimes you want degrees to appear in a particular order:

```{r}
students |>
  mutate(Degree = factor(Degree,
                         levels = c("Architecture", "Linguistics",
                                    "English", "Philosophy", "Education"))) |>
  ggplot(aes(x = Degree)) +
  geom_bar(fill = "steelblue4") +
  labs(x = "\n Degree subject", y = "Count \n")

```

### Reorder by frequency

```{r}
library(tidyverse)

students |>
  mutate(Degree = fct_infreq(students$Degree)) |>
  ggplot(aes(x = Degree)) +
  geom_bar(fill = "steelblue4") +
  labs(x = "\n Degree subject", y = "Count \n")

```

### What this does

-   `fct_infreq(Degree)`Â reorders DegreeÂ **from most common â†’ least common**.

-   The bar chart will display the degrees in order of their counts.

### **Reverse the order (least common â†’ most common)**

```{r}
students |>
  mutate(Degree = fct_rev(fct_infreq(Degree))) |>
  ggplot(aes(x = Degree)) +
  geom_bar(fill = "steelblue4") +
  labs(x = "\n Degree subject", y = "Count \n")

```

::: {.callout-tip title="Want to learn more about ggplot?"}
For a deeper explanation of **ggplot**, including the grammar of graphics,\
aesthetics, geoms, and themes, see the **Plots & Grammar page**.

[Plots and Grammar â€“ How ggplot Works](plots_grammar.qmd)
:::

::: panel-tabset
### `fct_infreq()`

**Meaning:**\
Reorders a factor so that categories appear from **most common â†’ least common**.

**Example:**\
If your Degree counts are:

-   Linguistics: 60 students\
-   English: 40 students\
-   Philosophy: 20 students\
-   Architecture: 10 students

Then:

fct_infreq(Degree)

reorders the categories as:

1.  Linguistics

2.  English

3.  Philosophy

4.  Architecture

This means your bar chart will display categories in order ofÂ **highest to lowest**Â frequency.

------------------------------------------------------------------------

### `fct_rev()`

**Meaning:**\
Reverses the order of the factor levels.

**Example (continuing from the previous one):**

If the order is:

1.  Linguistics

2.  English

3.  Philosophy

4.  Architecture

then:

fct_rev(Degree)

flips the order to:

1.  Architecture

2.  Philosophy

3.  English

4.  Linguistics

This givesÂ **lowest â†’ highest**Â frequency.

------------------------------------------------------------------------

### Combining them:Â `fct_rev(fct_infreq())`

**Meaning:**\
First reorder categories byÂ **frequency**, thenÂ **reverse**Â the order.

This gives a clear and useful order:

-   **from least common â†’ most common**

Example:

mutate(Degree = fct_rev(fct_infreq(students\$Degree)))

Step-by-step:

1.  `fct_infreq(Degree)`\
    â†’ orders fromÂ *most common â†’ least common*\
    (Linguistics â†’ English â†’ Philosophy â†’ Architecture)

2.  `fct_rev(...)`\
    â†’ reverses that order\
    (Architecture â†’ Philosophy â†’ English â†’ Linguistics)

This final arrangement is often helpful in bar charts because it starts with theÂ **smallest group**Â and ends with theÂ **largest**, making the pattern easy to read.
:::

## 6. Ordinal Data

Some categorical variables in theÂ `students`Â dataset have aÂ **natural order**. For example:

For example:

-   `Satisfaction_Likert_value`Â might range from 1 to 5, with\
    1 = â€œVery dissatisfiedâ€\
    5 = â€œVery satisfiedâ€

Although the values are stored as numbers, they representÂ **ordered categories**, not true numeric measurements.

### 6.1 Frequency table for an ordinal variable

```{r}
students |>
  count(Satisfaction_Likert_value)

```

### 6.2 We can again use relative frequencies:

```{r}
freq_sat <-
  students |>
  count(Satisfaction_Likert_value) |>
  mutate(
    percent = n / sum(n) * 100
  )

freq_sat

```

### 6.3 Median

Because the categories are ordered, we can talk about theÂ **median**.

> **Median**\
> The median is the value for which 50% of observations are lower and 50% are higher.\
> It is the middle value when all the observations are lined up in order.

We can find the median of the satisfaction ratings directly:

```{r}
median(as.numeric(students$Satisfaction_Likert_value))

```

> The median satisfaction rating is 4. This means that at least half of the students gave a rating of 4 (â€œSatisfiedâ€) or higher.

### 6.4 Cumulative percentages and quartiles

To find the median and quartiles, we can look atÂ **cumulative percentages**.

> **Cumulative percentage**\
> The cumulative percentage for a category is the percentage of observations in that categoryÂ **or below**Â it.

We can calculate cumulative percentages for the satisfaction ratings:

```{r}
students |>
  count(Satisfaction_Likert_value) |>
  mutate(
    percent = n / sum(n) * 100,
    cumulative_percent = cumsum(percent)
  )

```

From this table, we can work out theÂ **quartiles**Â and theÂ **median**:

-   **First quartile (Q1)**: the first category where the cumulative percentage isÂ **at least 25%**

-   **Median (Q2)**: the first category where the cumulative percentage isÂ **at least 50%**

-   **Third quartile (Q3)**: the first category where the cumulative percentage isÂ **at least 75%**

Using the values in the table:

-   Q1 occurs at the first category where cumulative percent â‰¥ 25% â†’Â **Likert value 2**

-   Q2 (the median) occurs at the first category where cumulative percent â‰¥ 50% â†’Â **Likert value 4**

-   Q3 occurs at the first category where cumulative percent â‰¥ 75% â†’Â **Likert value 4**

These quartiles give us a sense of how the data are distributed across the ordered categories.\
For example, in this case a large proportion of ratings lie in categoriesÂ **3, 4, and 5**, showing that satisfaction is generally on the higher end of the scale.

::: {.callout-tip title="Can we use the IQR with Likert data?"}
Yes â€“ R can calculate the IQR of a Likert scale because the responses are stored as numbers.

However, Likert responses are *ordinal*, not truly numeric.\
So the IQR should be interpreted in terms of **categories**, not as a precise numerical distance.

Use quartiles (Q1, Q2, Q3) from the cumulative percentage table to describe how spread out the responses are across the ordered scale.
:::

::: {.callout-tip title="Using the IQR and Quartiles with Likert Data"}
Because Likert values are stored as numbers, R can calculate quartiles (Q1, Q2, Q3) and even the IQR.\
However, a Likert scale is **ordinal**, not truly numeric, so we must interpret these values with care.

### âœ”ï¸ What you *can* safely do

Use quartiles to talk about how responses are spread across the **ordered categories**.

To do this properly:

1.  Identify **Q1**, **median (Q2)**, and **Q3** from the **cumulative percentage table**,\
    rather than relying on the raw numeric outputs.

2.  Treat these quartiles as **categories**, not measurements.

### âœ”ï¸ Safe interpretation example

Using our satisfaction ratings:

-   **Q1 = 2**\
-   **Median = 4**\
-   **Q3 = 4**

So:

> **Half of the students rated their satisfaction between 2 and 4 on the scale.**

This keeps the interpretation grounded in the **ordinal nature** of the data and avoids treating Likert responses as precise numeric units.
:::

## 7 Visualising ordinal data

We can visualise ordinal data much like nominal data.

First, we create a table with percentages:

```{r}
freq_sat <-
  students |>
  count(Satisfaction_Likert_value) |>
  mutate(
    percent = n / sum(n) * 100
  )

```

Then we plot:

```{r}
ggplot(data = freq_sat,
       aes(x = Satisfaction_Likert_value, y = percent)) +
  geom_col() +
  labs(
    x = "\n Satisfaction (1 = very dissatisfied, 5 = very satisfied)",
    y = "Percentage of students \n"
  )

```

This shows how the students are distributed across the satisfaction scale.

### Example 2 : Categorical variable (Year)

```{r}
ggplot(students, aes(x = Year)) +
  geom_bar(fill = "steelblue4") +
  labs(x = "\n Year of study", y = "Count \n")

```

For an ordered variable such asÂ `Year`, we can examineÂ **cumulative percentages**.

```{r}
students |>
  count(Year) |>
  mutate(
    Percent    = round((n / sum(n)) * 100, 2),
    Cumulative = cumsum(Percent)
  )

```

This helps us see:

-   where theÂ **25%**Â point lies (Q1)

-   where theÂ **50%**Â point lies (median)

-   where theÂ **75%**Â point lies (Q3)

**Checking quartiles in R**

```{r}
quantile(students$Year, c(0.25, 0.75))

```

**Interquartile range (IQR)**

```{r}
IQR(students$Year)

```

**Median Year**

```{r}
median(students$Year)

```

These summaries are useful when we want to understand how students are distributed across levels of an ordered attribute.

## 8. Glossary

| Term / Function | Meaning |
|----|----|
| **distribution** | How often different possible values of a variable occur. |
| **frequency** | Number of observations in a given category (a count). |
| **relative frequency** | Proportion or percentage of observations in a given category. |
| **cumulative percentage** | Percentage of observations in or below a given category (requires ordered data). |
| **mode** | Most common value (the category with the highest frequency). |
| **median** | Middle value when the data are ordered. |
| **`|>`** | Pipe operator. Takes the output on the left and passes it as input to the function on the right. |
| **`count()`** | Counts the number of occurrences of each unique value in a variable. |
| **`mutate()`** | Adds new variables or modifies existing variables in a dataframe. |
| **`median()`** | Returns the median of a numeric or ordered variable. |
| **`ggplot()`** | Creates a plot. Uses `data =` and `aes()` to map variables to plot features (e.g. x-axis, y-axis, colours). |
| **`geom_col()`** | Adds columns (bars) to a ggplot using the supplied y-values. |

::: callout-note
For more examples of ggplot and the grammar of graphics, see\
[Plots and the Grammar of Graphics](Plots_and_grammar.qmd).
:::
